esphome:
  name: 4-slave-co2
  platformio_options:
    platform: https://github.com/mnowak32/platform-espressif32.git#boards/seeed_xiao_esp32c6
  includes:
    - components/espnow_send_custom_data/espnow_send_custom_data.h
    - components/espnow_send_custom_data/espnow_send_custom_data.cpp
  on_boot:
    priority: -10000
    then:
      - lambda: |-
          ESP_LOGI("main", "Hub address: 0x%12llx", id(hub_address));
      # - lambda: |-
      #     // Set calibration data to spectral sensor
      #     id(spectral_sensor).setup_atime(id(atime));
      #     id(spectral_sensor).setup_astep(id(astep));
      #     id(spectral_sensor).setup_gain(static_cast<esphome::as7343::AS7343Gain>(id(gain)));
      - delay: 500ms
      - lambda: |-
          id(espnow_component)->add_peer(id(hub_address));
      - delay: 500ms
      - if:
          condition:
            lambda: 'return id(deep_sleep_button).state;'
          then:
            - deep_sleep.prevent: deep_sleep_1
          else:
            - script.execute: espnow_communication

esp32:
  board: seeed_xiao_esp32c6
  variant: ESP32C6
  flash_size: 4MB
  framework:
    type: esp-idf
    version: 5.2.1
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y

logger:
  baud_rate: 115200
  level: DEBUG
  hardware_uart: USB_SERIAL_JTAG

deep_sleep:
  id: deep_sleep_1
  run_duration: 80s # Time for the ESP32 to run before entering sleep mode
  sleep_duration: 60s # Change this to your desired sleep time
  wakeup_pin:
    number: GPIO0
    allow_other_uses: true
  wakeup_pin_mode: IGNORE

globals:
  - id: long_press_timer
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: long_press_action
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: pinged
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: paring
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: hub_address
    type: uint64_t
    initial_value: '0xFFFFFFFFFFFF'
    restore_value: yes

  - id: get_calibration
    type: bool
    initial_value: 'false'

  - id: request_cal
    type: bool
    initial_value: 'false'

i2c:
  sda: GPIO22
  scl: GPIO23
  scan: False

sensor:
  - platform: bmp280_i2c
    id: bmp280_sensor
    temperature:
      name: 'Temperature (BMP280)'
      id: bmp280_temp
      oversampling: 16x
    pressure:
      name: 'Pressure'
      id: bmp280_press
      oversampling: 16x
    iir_filter: 4x
    address: 0x76
    update_interval: never
  - platform: htu21d
    id: si7021_sensor
    temperature:
      name: 'Temperature (Si7021)'
      id: si7021_temp
    humidity:
      name: 'Humidity'
      id: si7021_hum
    address: 0x40
    update_interval: never
  - platform: ccs811
    id: ccs811_sensor
    eco2:
      name: 'CCS811 eCO2 Value'
      id: ccs811_eco2
    tvoc:
      name: 'CCS811 Total Volatile Organic Compound'
      id: ccs811_tvoc
    temperature: bmp280_temp
    humidity: si7021_hum
    address: 0x5A
    update_interval: never

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO0
      allow_other_uses: true
    name: 'Button'
    id: 'deep_sleep_button'
    on_state:
      then:
        - if:
            condition:
              lambda: 'return !x;'
            then:
              - logger.log: 'Button pressed'
              - deep_sleep.enter: deep_sleep_1
  - platform: gpio
    pin:
      number: GPIO19 # replace with the actual GPIO number
      mode: INPUT_PULLUP
      inverted: true
    name: 'Long Press Button'
    id: long_press_button
    on_press:
      then:
        - lambda: |-
            id(long_press_timer) = millis();
    on_release:
      then:
        - lambda: |-
            if (millis() - id(long_press_timer) > 3000) {
                ESP_LOGD("main", "Button was pressed for longer than 3 seconds.");
                id(long_press_action) = true;
                }
            else {ESP_LOGD("main", "Button was pressed for less than 3 seconds.");}

espnow:
  id: espnow_component
  auto_add_peer: true
  wifi_channel: !secret espnow_channel
  predefined_peers:
    - FF:FF:FF:FF:FF:FF
  on_receive:
    then:
      - lambda: |-
          std::string received_string((char*)packet.get_payload(), packet.size);

          if(packet.is_valid()){
            // Convert the received data to a string
            std::string received_string((char*)packet.get_payload(), packet.size);
            ESP_LOGI("main", "Received data: %s", received_string.c_str());

            if(received_string == "ping") {
                if(id(long_press_action)) {
                    id(hub_address) = packet.peer;
                    ESP_LOGI("main", "Setting hub address: 0x%12llx", id(hub_address));
                    id(long_press_action) = false;
                    id(paring) = true;
                }
                id(pinged) = true;
            }
            if(packet.peer == id(hub_address)) {
                ESP_LOGI("main", "Received from hub");
                 // Parse the received data
                char buffer[241];

                strncpy(buffer, received_string.c_str(), sizeof(buffer));

                char* topic = strtok(buffer, ";");
                char* value = strtok(nullptr, ";");
                char* end = strtok(nullptr, ";");
            }
            else {ESP_LOGW("main", "Received from unknown peer. Not accepting data from unknown peers.");}
          }
          else{ESP_LOGW("main", "Invalid packet");}
      - script.execute: handleOnRecieve

external_components:
  - source:
      type: git
      url: https://github.com/nielsnl68/esphome
      ref: d23346165e1baefd337ed805d3a211e5bead53af
    refresh: 1min
    components: [espnow]

script:
  - id: 'espnow_communication'
    then:
      - script.execute: beReadyToReceiveMessage
      - logger.log: 'Updating sensor data'
      - component.update: bmp280_sensor
      - component.update: si7021_sensor
      - component.update: ccs811_sensor
      - delay: 3s
      - logger.log: 'Sensor data updated'
      - repeat:
          count: 3
          then:
            - logger.log: 'Sending data to hub'
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("bmp_temp", id(bmp280_temp).state*100000);
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("bmp_press", id(bmp280_press).state*100000);
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("si_temp", id(si7021_temp).state*100000);
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("si_hum", id(si7021_hum).state*100000);
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("ccs_eco2", id(ccs811_eco2).state);
            - delay: 500ms
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data_new("ccs_tvoc", id(ccs811_tvoc).state);
  - id: beReadyToReceiveMessage
    then:
      - espnow.send:
          mac_address: !lambda 'return id(hub_address);'
          payload: 'hub;beReadyToReceiveMessage'
      - delay: 500ms
  - id: handleOnRecieve
    then:
      - if:
          condition:
            lambda: 'return id(pinged);'
          then:
            - logger.log: 'Pinging back'
            - espnow.send:
                mac_address: !lambda 'return id(hub_address);'
                payload: !lambda |-
                  return format_espnow_data("pong", "44", id(paring));
            - lambda: |-
                id(paring) = false;
                id(pinged) = false;
      - if:
          condition:
            lambda: 'return id(get_calibration);'
          then:
            - logger.log: 'Sending calibration data'
            #- script.execute: sendCalibrationData
            - lambda: |-
                id(get_calibration) = false;
